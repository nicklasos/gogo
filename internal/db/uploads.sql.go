// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: uploads.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUpload = `-- name: CreateUpload :one
INSERT INTO uploads (
    user_id, folder_id, type, relative_path, original_filename, file_size, mime_type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, folder_id, type, relative_path, original_filename, file_size, mime_type, created_at, updated_at
`

type CreateUploadParams struct {
	UserID           int32       `db:"user_id" json:"user_id"`
	FolderID         int32       `db:"folder_id" json:"folder_id"`
	Type             string      `db:"type" json:"type"`
	RelativePath     string      `db:"relative_path" json:"relative_path"`
	OriginalFilename string      `db:"original_filename" json:"original_filename"`
	FileSize         int64       `db:"file_size" json:"file_size"`
	MimeType         pgtype.Text `db:"mime_type" json:"mime_type"`
}

func (q *Queries) CreateUpload(ctx context.Context, arg CreateUploadParams) (Upload, error) {
	row := q.db.QueryRow(ctx, createUpload,
		arg.UserID,
		arg.FolderID,
		arg.Type,
		arg.RelativePath,
		arg.OriginalFilename,
		arg.FileSize,
		arg.MimeType,
	)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FolderID,
		&i.Type,
		&i.RelativePath,
		&i.OriginalFilename,
		&i.FileSize,
		&i.MimeType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUpload = `-- name: DeleteUpload :exec
DELETE FROM uploads
WHERE id = $1 AND user_id = $2
`

type DeleteUploadParams struct {
	ID     int32 `db:"id" json:"id"`
	UserID int32 `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteUpload(ctx context.Context, arg DeleteUploadParams) error {
	_, err := q.db.Exec(ctx, deleteUpload, arg.ID, arg.UserID)
	return err
}

const getUploadByID = `-- name: GetUploadByID :one
SELECT id, user_id, folder_id, type, relative_path, original_filename, file_size, mime_type, created_at, updated_at FROM uploads
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUploadByID(ctx context.Context, id int32) (Upload, error) {
	row := q.db.QueryRow(ctx, getUploadByID, id)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FolderID,
		&i.Type,
		&i.RelativePath,
		&i.OriginalFilename,
		&i.FileSize,
		&i.MimeType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUploadByIDAndUserID = `-- name: GetUploadByIDAndUserID :one
SELECT id, user_id, folder_id, type, relative_path, original_filename, file_size, mime_type, created_at, updated_at FROM uploads
WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetUploadByIDAndUserIDParams struct {
	ID     int32 `db:"id" json:"id"`
	UserID int32 `db:"user_id" json:"user_id"`
}

func (q *Queries) GetUploadByIDAndUserID(ctx context.Context, arg GetUploadByIDAndUserIDParams) (Upload, error) {
	row := q.db.QueryRow(ctx, getUploadByIDAndUserID, arg.ID, arg.UserID)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FolderID,
		&i.Type,
		&i.RelativePath,
		&i.OriginalFilename,
		&i.FileSize,
		&i.MimeType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUploadByPath = `-- name: GetUploadByPath :one
SELECT id, user_id, folder_id, type, relative_path, original_filename, file_size, mime_type, created_at, updated_at FROM uploads
WHERE relative_path = $1 LIMIT 1
`

func (q *Queries) GetUploadByPath(ctx context.Context, relativePath string) (Upload, error) {
	row := q.db.QueryRow(ctx, getUploadByPath, relativePath)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FolderID,
		&i.Type,
		&i.RelativePath,
		&i.OriginalFilename,
		&i.FileSize,
		&i.MimeType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUploadsByFolderID = `-- name: ListUploadsByFolderID :many
SELECT id, user_id, folder_id, type, relative_path, original_filename, file_size, mime_type, created_at, updated_at FROM uploads
WHERE folder_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUploadsByFolderID(ctx context.Context, folderID int32) ([]Upload, error) {
	rows, err := q.db.Query(ctx, listUploadsByFolderID, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Upload
	for rows.Next() {
		var i Upload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Type,
			&i.RelativePath,
			&i.OriginalFilename,
			&i.FileSize,
			&i.MimeType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadsByUserID = `-- name: ListUploadsByUserID :many
SELECT id, user_id, folder_id, type, relative_path, original_filename, file_size, mime_type, created_at, updated_at FROM uploads
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUploadsByUserID(ctx context.Context, userID int32) ([]Upload, error) {
	rows, err := q.db.Query(ctx, listUploadsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Upload
	for rows.Next() {
		var i Upload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FolderID,
			&i.Type,
			&i.RelativePath,
			&i.OriginalFilename,
			&i.FileSize,
			&i.MimeType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
